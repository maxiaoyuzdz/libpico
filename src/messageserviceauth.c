/** \ingroup Message
 * @file
 * @author  David Llewellyn-Jones <David.Llewellyn-Jones@cl.cam.ac.uk>
 * @version $(VERSION)
 *
 * @section LICENSE
 *
 * (C) Copyright Cambridge Authentication Ltd, 2017
 *
 * This file is part of libpico.
 *
 * Libpico is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * Libpico is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public
 * License along with libpico. If not, see
 * <http://www.gnu.org/licenses/>.
 *
 *
 * @brief Message for authenticating the verifier to the prover
 * @section DESCRIPTION
 *
 * The MessageServiceAuth class allows a ServiceAuth message to ge generated by
 * the server to be sent to the Pico.
 * 
 * This represents the second message forming the first round trip of the
 * Sigma-I protocol:
 * QR-code (KeyAuth or KeyPair); Start; ServiceAuth; PicoAuth; Status.
 *
 * The structure of the message is as follows
 * {"serviceEphemPublicKey":"B64-PUB-KEY","serviceNonce":"B64-NONCE","sessionId":0,"encryptedData":"B64-ENC","iv":"B64"}
 *
 */

/** \addtogroup Message
 *  @{
 */

#include <stdio.h>
#include <malloc.h>
#include "pico/debug.h"
#include "pico/base64.h"
#include "pico/keypair.h"
#include "pico/sigmakeyderiv.h"
#include "pico/keyagreement.h"
#include "pico/json.h"
#include "pico/buffer.h"
#include "pico/cryptosupport.h"
#include "pico/log.h"
#include "pico/messageserviceauth.h"

// Defines

// Structure definitions

/**
 * @brief Structure for storing service authentication message details
 *
 * Opaque structure containing the private fields of the MessageServiceAuth
 * class.
 *
 * This is provided as the first parameter of every non-static function and 
 * stores the operation's context.
 * 
 * The structure typedef is in messageserviceauth.h
 */
struct _MessageServiceAuth {
	Shared * shared;
	int sessionId;
	Buffer * iv;
	Buffer * encryptedData;

	Buffer * signature;
	Buffer * mac;
};

// Function prototypes

void messageserviceauth_get_bytes_to_sign(MessageServiceAuth * messageserviceauth, Buffer * buffer);
void messageserviceauth_generate_signature(MessageServiceAuth * messageserviceauth, Buffer * bufferout);
bool messageserviceauth_verify_signature(MessageServiceAuth * messageserviceauth, Buffer * sigin);
// Function definitions

/**
 * Create a new instance of the class.
 *
 * @return The newly created object.
 */
MessageServiceAuth * messageserviceauth_new() {
	MessageServiceAuth * messageserviceauth;

	messageserviceauth = CALLOC(sizeof(MessageServiceAuth), 1);
	
	messageserviceauth->iv = buffer_new(CRYPTOSUPPORT_IV_SIZE);
	messageserviceauth->encryptedData = buffer_new(0);

	messageserviceauth->signature = buffer_new(0);
	messageserviceauth->mac = buffer_new(0);

	return messageserviceauth;
}

/**
 * Delete an instance of the class, freeing up the memory allocated to it.
 *
 * @param messageserviceauth The object to free.
 */
void messageserviceauth_delete(MessageServiceAuth * messageserviceauth) {
	if (messageserviceauth) {
		if (messageserviceauth->iv) {
			buffer_delete(messageserviceauth->iv);
		}
		if (messageserviceauth->encryptedData) {
			buffer_delete(messageserviceauth->encryptedData);
		}
		if (messageserviceauth->signature) {
			buffer_delete(messageserviceauth->signature);
		}
		if (messageserviceauth->mac) {
			buffer_delete(messageserviceauth->mac);
		}

		FREE(messageserviceauth);
	}
}

/**
 * Populate the messageserviceauth object with data so it's ready for use.
 *
 * @param messageserviceauth The MessageServiceAuth object to set the data for
 * @param shared Object containing data shared across messages
 * @param sessionId The session ID. Currently this can be set to anything.
 */
void messageserviceauth_set(MessageServiceAuth * messageserviceauth, Shared * shared, int sessionId) {
	messageserviceauth->shared = shared;
	messageserviceauth->sessionId = sessionId;
}

/**
 * Internal function used to pull together the data that the signature covers.
 *
 * @param messageserviceauth The MessageServiceAuth object to get the data from.
 * @param buffer A buffer for the output to be returned in
 */
void messageserviceauth_get_bytes_to_sign(MessageServiceAuth * messageserviceauth, Buffer * buffer) {
	unsigned char const * string;
	size_t length;
	char writeInt[4];
	Buffer * toAppend;
	Nonce * picoNonce;
	//KeyPair * serviceEphemeralKey;
	EC_KEY * serviceEphemeralKey;

	buffer_clear(buffer);

	picoNonce = shared_get_pico_nonce(messageserviceauth->shared);
	string = nonce_get_buffer(picoNonce);
	length = nonce_get_length(picoNonce);
	buffer_append(buffer, string, length);

	writeInt[0] = ((char *)(& messageserviceauth->sessionId))[3];
	writeInt[1] = ((char *)(& messageserviceauth->sessionId))[2];
	writeInt[2] = ((char *)(& messageserviceauth->sessionId))[1];
	writeInt[3] = ((char *)(& messageserviceauth->sessionId))[0];
	buffer_append(buffer, writeInt, 4);

	toAppend = buffer_new(0);
	// TODO: Fix retrieval of service ephemeral key in libpico
	//serviceEphemeralKey = shared_get_service_ephemeral_key(messageserviceauth->shared);
	serviceEphemeralKey = shared_get_service_ephemeral_public_key(messageserviceauth->shared);

	//keypair_getpublicder(serviceEphemeralKey, toAppend);
	cryptosupport_getpublicder(serviceEphemeralKey, buffer);

	buffer_append_buffer(buffer, toAppend);
	buffer_delete(toAppend);
}

/**
 * Generate the signature included in a ServiceAuth message to be sent to the
 * Pico. This will generate the signature using the Service's long-term 
 * identity key and the data collected using the 
 * messageserviceauth_get_bytes_to_sign() function.
 *
 * @param messageserviceauth The MessageServiceAuth object to add the signature
 *                           to
 * @param buffer A buffer object to store the result in
 */
void messageserviceauth_generate_signature(MessageServiceAuth * messageserviceauth, Buffer * bufferout) {
	Buffer * bufferin;
	KeyPair * serviceIdentityKey;
	
	bufferin = buffer_new(0);

	messageserviceauth_get_bytes_to_sign(messageserviceauth, bufferin);


	serviceIdentityKey = shared_get_service_identity_key(messageserviceauth->shared);
	keypair_sign_data(serviceIdentityKey, bufferin, bufferout);

	buffer_delete(bufferin);
}

/**
 * Verify the signature included in a ServiceAuth message received from a Service.
 * This will verify the signature using the Service's long-term identity key
 * and the data collected using the messageserviceauth_get_bytes_to_sign()
 * function.
 *
 * @param messageserviceauth The MessageServiceAuth object to test the signature of
 * @param sigin The signature to check
 * @return true if the signature was valid, false if it was invalid, or 
 *         an error occurred during the validation process
 */
bool messageserviceauth_verify_signature(MessageServiceAuth * messageserviceauth, Buffer * sigin) {
	Buffer * bufferin;
	bool result;
	//KeyPair * serviceIdentityKey;
	EC_KEY * serviceIdentityPublicKey;

	bufferin = buffer_new(0);

	messageserviceauth_get_bytes_to_sign(messageserviceauth, bufferin);

	serviceIdentityPublicKey = shared_get_service_identity_public_key(messageserviceauth->shared);
	if ((serviceIdentityPublicKey != NULL) && (bufferin != NULL) && (sigin != NULL)) {
		  result = cryptosupport_verify_signature(serviceIdentityPublicKey, bufferin, sigin);
	}
	else {
		  result = false;
	}

	//result = true;

	buffer_delete(bufferin);
	return result;
}

/**
 * Serialize the Service Auth data in JSON format.
 *
 * @param keyauth The object for serialization
 * @param buffer Memory buffer to store the result in
 */
void messageserviceauth_serialize(MessageServiceAuth * messageserviceauth, Buffer * buffer) {
	Json * json;
	Buffer * encrypted;
	Buffer * iv;
	Buffer * encoded;
	Buffer * toEncrypt;
	Buffer * vEncKey;
	Buffer * vMacKey;
	Buffer * serviceIdPubEncoded;
	Nonce * serviceNonce;
	KeyPair * serviceEphemeralKey;
	KeyPair * serviceIdentityKey;

	json = json_new();
	encoded = buffer_new(0);
	
	json_add_integer(json, "sessionId", messageserviceauth->sessionId);

	// Generate shared secrets
	//pMacKey = buffer_new(32); // 256 bits
	//pEncKey = buffer_new(16); // 128 bits
	//vMacKey = buffer_new(32); // 256 bits
	//vEncKey = buffer_new(16); // 128 bits
	//sharedKey = buffer_new(16); // 128 bits

	shared_generate_shared_secrets(messageserviceauth->shared);

	//buffer_delete(pMacKey);
	//buffer_delete(pEncKey);
	//buffer_delete(sharedKey);

	// Encrypted data
	toEncrypt = buffer_new(0);

	// servicePublicKeyBytes
	buffer_clear(encoded);
	serviceIdentityKey = shared_get_service_identity_key(messageserviceauth->shared);
	keypair_getpublicder(serviceIdentityKey, encoded);
	buffer_append_buffer_lengthprepend(toEncrypt, encoded);

	// signature
	buffer_clear(encoded);
	messageserviceauth_generate_signature(messageserviceauth, encoded);
	buffer_append_buffer_lengthprepend(toEncrypt, encoded);

	// mac
	buffer_clear(encoded);
	serviceIdPubEncoded = buffer_new(0);
	keypair_getpublicder(serviceIdentityKey, serviceIdPubEncoded);

	vMacKey = shared_get_verifier_mac_key(messageserviceauth->shared);
	cryptosupport_generate_mac(vMacKey, serviceIdPubEncoded, encoded);
	buffer_delete(serviceIdPubEncoded);

	buffer_append_buffer_lengthprepend(toEncrypt, encoded);

	// Perform the encryption
	iv = buffer_new(CRYPTOSUPPORT_IV_SIZE);
	cryptosupport_generate_iv(iv);

	encrypted = buffer_new(0);
	
	vEncKey = shared_get_verifier_enc_key(messageserviceauth->shared);	
	cryptosupport_encrypt(vEncKey, iv, toEncrypt, encrypted);

	buffer_clear(encoded);
	base64_encode_buffer(encrypted, encoded);

	json_add_buffer(json, "encryptedData", encoded);

	buffer_clear(encoded);
	base64_encode_buffer(iv, encoded);
	
	json_add_buffer(json, "iv", encoded);
	buffer_delete(iv);

	buffer_clear(encoded);
	serviceEphemeralKey = shared_get_service_ephemeral_key(messageserviceauth->shared);
	keypair_getpublicpem(serviceEphemeralKey, encoded);
	json_add_buffer(json, "serviceEphemPublicKey", encoded);

	buffer_clear(encoded);
	serviceNonce = shared_get_service_nonce(messageserviceauth->shared);
	base64_encode_mem((char const *)nonce_get_buffer(serviceNonce), nonce_get_length(serviceNonce), encoded);
	json_add_buffer(json, "serviceNonce", encoded);

	buffer_delete(encrypted);
	buffer_delete(toEncrypt);
	buffer_delete(encoded);

	json_serialize_buffer(json, buffer);
	json_delete(json);
}

/**
 * Deserialize a Service message JSON string and store the data collected 
 * from it into the messageserviceauth object.
 *
 * The function will return false if the deserialization fails. Reasons
 * for failure include:
 *  - A malformed JSON string
 *  - Signature is invalid
 *
 * @param messageserviceauth The MessageServiceAuth object to store the 
 * deserialized data into
 * @param buffer The JSON string to deserialize
 * @return true if the message was deserialized correctly, false o/w.
 */
bool messageserviceauth_deserialize(MessageServiceAuth * messageserviceauth, Buffer const * buffer) {
	Json * json;
	char const * value;
	Buffer * cleartext;
	size_t start;
	size_t next;
	Buffer * mac;
	bool result;
	Buffer * servicePublicKeyBytes;
	EC_KEY * serviceIdentityPublicKey;
	Buffer * vEncKey;
	Buffer * vMacKey;
	Buffer * serviceIdentityPubEncoded;
	Nonce * verifierNonce;
	Buffer * base64;

	json = json_new();
	result = json_deserialize_buffer(json, buffer);
	servicePublicKeyBytes = buffer_new(0);
	if (result) {
		if (json_get_type(json, "sessionId") == JSONTYPE_INTEGER) {
			messageserviceauth->sessionId = json_get_integer(json, "sessionId");
		}
		else {
			LOG(LOG_ERR, "Missing sessionId\n");
			result = false;
		}
	}
	if (result) {
		value = json_get_string(json, "iv");
		if (value) {
			base64_decode_string(value, messageserviceauth->iv);
		}
		else {
			LOG(LOG_ERR, "Missing iv\n");
			result = false;
		}
	}
	if (result) {
		value = json_get_string(json, "serviceEphemPublicKey");
		if (value) {
			shared_set_service_ephemeral_public_key(messageserviceauth->shared, cryptosupport_read_base64_string_public_key(value));
		}
		else {
			LOG(LOG_ERR, "Missing serviceEphemPublicKey\n");
			result = false;
		}
	}
	if (result) {
		value = json_get_string(json, "encryptedData");
		if (value) {
			base64_decode_string(value, messageserviceauth->encryptedData);
		}
		else {
			LOG(LOG_ERR, "Missing encryptedData\n");
			result = false;
		}
	}
	if (result) {
		value = json_get_string(json, "serviceNonce");
		if (value) {
			verifierNonce = shared_get_service_nonce(messageserviceauth->shared);
			base64 = buffer_new(NONCE_DEFAULT_BYTES);
			base64_decode_string(value, base64);
			nonce_set_buffer(verifierNonce, base64);
			buffer_delete(base64);
		}
		else {
			LOG(LOG_ERR, "Missing serviceNonce\n");
			result = false;
		}
	}
	if (result) {
		shared_generate_shared_secrets_pico(messageserviceauth->shared);
	}
	cleartext = buffer_new(0);
	if (result) {
		vEncKey = shared_get_verifier_enc_key(messageserviceauth->shared);
		result = cryptosupport_decrypt(vEncKey, messageserviceauth->iv, messageserviceauth->encryptedData, cleartext);
	}
	start = 0;
	if (result) {
		next = buffer_copy_lengthprepend(cleartext, start, servicePublicKeyBytes);
		if (next > start) {
			serviceIdentityPublicKey = cryptosupport_read_buffer_public_key(servicePublicKeyBytes);
			shared_set_service_identity_public_key(messageserviceauth->shared, serviceIdentityPublicKey);
			start = next;
		}
		else {
			LOG(LOG_ERR, "Error deserializing decrypted length-prepended servicePublicKeyBytes data\n");
			result = false;
		}
	}
	if (result) {
		next = buffer_copy_lengthprepend(cleartext, start, messageserviceauth->signature);
		if (next > start) {
			start = next;
		}
		else {
			LOG(LOG_ERR, "Error deserializing decrypted length-prepended signature data\n");
			result = false;
		}
	}
	if (result) {
		next = buffer_copy_lengthprepend(cleartext, start, messageserviceauth->mac);
		if (next > start) {
			start = next;
		}
		else {
			LOG(LOG_ERR, "Error deserializing decrypted length-prepended mac data\n");
			result = false;
		}
	}

	if (result) {
		// If we got here successfully, it is expected to have consumed the whole buffer
		result = start == buffer_get_pos(cleartext);
	}

	buffer_delete(cleartext);

	if (result) {
		result = messageserviceauth_verify_signature(messageserviceauth, messageserviceauth->signature);
		if (!result) {
			LOG(LOG_ERR, "Invalid signature.\n");
		}
	}
	if (result) {
		mac = buffer_new(0);
		vMacKey = shared_get_verifier_mac_key(messageserviceauth->shared);
		serviceIdentityPubEncoded = buffer_new(0);
		serviceIdentityPublicKey = shared_get_service_identity_public_key(messageserviceauth->shared);
		cryptosupport_getpublicder(serviceIdentityPublicKey, serviceIdentityPubEncoded);
		cryptosupport_generate_mac(vMacKey, serviceIdentityPubEncoded, mac);
		buffer_delete(serviceIdentityPubEncoded);

		result = buffer_equals(mac, messageserviceauth->mac);
		if (!result) {
			LOG(LOG_ERR, "HMAC failure.\n");
		}
		buffer_delete(mac);
	}
	buffer_delete(servicePublicKeyBytes);
	json_delete(json);
	return result;
}

/** @} addtogroup Message */

